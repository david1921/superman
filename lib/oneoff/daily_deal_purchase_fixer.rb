module Oneoff

  class DailyDealPurchaseFixer

    BROKEN_PURCHASES_QUERY = %Q{
SELECT DISTINCT p.label publisher_label, dd.id deal_id, ddp.created_at purchase_created_at,
                ddp.executed_at purchase_executed_at, ddp.refunded_at purchase_refunded_at,
                ddp.id purchase_id, ddt.value_proposition value_prop, ddp.payment_status purchase_status,
                ddp.actual_purchase_price actual_purchase_price, ddc.id certificate_id, ddc.status certificate_status
FROM daily_deal_purchases ddp
  LEFT OUTER JOIN daily_deal_certificates ddc ON ddc.daily_deal_purchase_id = ddp.id
  INNER JOIN daily_deals dd ON ddp.daily_deal_id = dd.id
  INNER JOIN publishers p ON dd.publisher_id = p.id
  INNER JOIN daily_deal_translations ddt ON ddt.daily_deal_id = dd.id
WHERE ddp.payment_status IN ('captured', 'refunded')
  AND ddp.id IN (?)
  AND ddp.type = 'DailyDealPurchase'
  AND ddc.id IS NULL
ORDER BY executed_at DESC
}

    REFUNDED_AT_PER_ACCOUNTING = Time.zone.parse("2012-07-16 9:00 PDT")

    def generate_broken_purchases_and_vouchers_report!
      purchase_ids = get_purchase_ids_file.readlines
      csv_file = FasterCSV.new(get_outfile, :force_quotes => true)
      csv_columns = %w(publisher_label purchase_id purchase_created_at purchase_executed_at
                       purchase_refunded_at deal_id value_prop purchase_status actual_purchase_price
                       certificate_id certificate_status)
      csv_file << csv_columns
      DailyDealPurchase.find_by_sql([BROKEN_PURCHASES_QUERY, purchase_ids]).each do |p|
        csv_file << csv_columns.map { |col_name| p.send(col_name) }
      end
    end

    def fix_purchases_with_missing_vouchers!(options = {})
      purchase_ids_file = ENV["PURCHASE_IDS_FILE"]

      unless purchase_ids_file.present?
        raise ArgumentError, "missing required argument PURCHASE_IDS_FILE"
      end

      successful_count = 0
      errors = []
      File.open(purchase_ids_file).each_line do |purchase_id|
        allow_retry = true
        begin
          purchase = DailyDealPurchase.find(purchase_id)
          generate_vouchers_for_purchase_missing_vouchers(purchase, options)
          successful_count += 1
        rescue Exception => e
          if e.message =~ /No unassigned barcodes found/i && allow_retry
            allow_retry = false
            purchase.quantity.times do
              purchase.daily_deal.bar_codes.create! :code => "ANA-#{ActiveSupport::SecureRandom.hex(4)}"
            end
            retry
          elsif e.message =~ /Redeemer name can't be blank/i && allow_retry
            allow_retry = false
            c = purchase.consumer
            c.name = "Unknown"
            c.save(false)
            retry
          else
            errors << [purchase, e]
          end
        end
      end

      [successful_count, errors]
    end

    def generate_vouchers_for_purchase_missing_vouchers(purchase, options = {})
      skip_generating_certs = options.fetch(:skip_generating_certs, false)
      skip_purchase_validation_on_save = options.fetch(:skip_purchase_validation_on_save, false)

      unless purchase.type.to_s == "DailyDealPurchase"
        raise ArgumentError, "can't generate vouchers for #{purchase.payment_status} DailyDealPurchase #{purchase.id}; type must be DailyDealPurchase, but is #{purchase.type}"
      end

      unless purchase.daily_deal.using_internal_serial_numbers?
        raise NotImplementedError, "generating missing vouchers is not supported for third party deals"
      end

      unless purchase.daily_deal_certificates.blank? || skip_generating_certs
        raise ArgumentError, "can't generate vouchers for #{purchase.payment_status} DailyDealPurchase #{purchase.id}; this purchase already has vouchers"
      end

      unless purchase.refunded? || purchase.captured?
        raise ArgumentError, "can't generate vouchers for #{purchase.payment_status} DailyDealPurchase #{purchase.id}; purchase must be refunded or captured"
      end

      if purchase.refunded? && purchase.refund_amount < purchase.actual_purchase_price
        raise NotImplementedError, "generating missing vouchers is not supported for partial refunds"
      end

      certificate_status = if purchase.captured?
        DailyDealCertificate::ACTIVE
      elsif purchase.refunded?
        DailyDealCertificate::REFUNDED
      else
        raise "error determining certificate status for DailyDealPurchase #{purchase.id}"
      end

      DailyDealPurchase.transaction do
        purchase.create_certificates! unless skip_generating_certs
        purchase.memo = "had vouchers regenerated by Brad B. as part of fixing https://www.pivotaltracker.com/story/show/31784553"
        purchase.refunded_at = REFUNDED_AT_PER_ACCOUNTING if purchase.refunded?
        if skip_purchase_validation_on_save
          purchase.save(false)
        else
          purchase.save!
        end

        purchase.reload.daily_deal_certificates.each do |c|
          c.status = certificate_status
          if purchase.refunded?
            c.refunded_at = REFUNDED_AT_PER_ACCOUNTING
            c.refund_amount = c.actual_purchase_price
          end
          c.save!
        end
      end
    end

    private
      
    def get_purchase_ids_file
      purchase_ids_file = ENV["PURCHASE_IDS_FILE"]
      unless purchase_ids_file.present?
        raise ArgumentError, "missing required argument PURCHASE_IDS_FILE"
      end
      File.open(purchase_ids_file)
    end

    def get_outfile
      outfile = ENV["OUTFILE"]
      unless outfile.present?
        raise ArgumentError, "missing required argument OUTFILE"
      end
      File.open(outfile, "w")
    end

  end
  
end
